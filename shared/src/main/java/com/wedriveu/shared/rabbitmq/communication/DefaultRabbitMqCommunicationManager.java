package com.wedriveu.shared.rabbitmq.communication;

import com.rabbitmq.client.*;
import com.wedriveu.shared.rabbitmq.communication.config.RabbitMqCommunicationConfig;
import com.wedriveu.shared.rabbitmq.communication.config.RabbitMqQueueConfig;
import com.wedriveu.shared.rabbitmq.communication.strategy.RabbitMqCloseCommunicationStrategy;
import com.wedriveu.shared.rabbitmq.communication.strategy.RabbitMqConsumerStrategy;
import com.wedriveu.shared.util.Log;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.TimeoutException;

/**
 * @author Nicola Lasagni on 09/08/2017.
 */
public class DefaultRabbitMqCommunicationManager implements RabbitMqCommunicationManager {

    private static final long SUBSCRIBER_TIME = 1000;
    private static final String ILLEGAL_COMMUNICATION_STATE =
            "Communication has not been set up or has been closed";

    private int subscribersCounter;
    private RabbitMqCommunication mCommunication;
    private Map<Integer, Thread> subscribers = new HashMap<>();

    private void checkState() throws IllegalStateException {
        if (mCommunication == null ||
                mCommunication.getChannel() == null ||
                !mCommunication.getChannel().isOpen()) {
            throw new IllegalStateException(ILLEGAL_COMMUNICATION_STATE);
        }
    }

    @Override
    public void setUpCommunication(RabbitMqCommunicationConfig config) throws IOException, TimeoutException {
        mCommunication = RabbitMqCommunicationFactory.getInstance().createCommunication(config);
    }

    @Override
    public String addAutoGeneratedQueue() throws IllegalStateException, IOException {
        checkState();
        return mCommunication.getChannel().queueDeclare().getQueue();
    }

    @Override
    public void addQueue(RabbitMqQueueConfig config) throws IOException {
        checkState();
        mCommunication.getChannel().queueDeclare(config.getQueueName(),
                config.isDurable(),
                config.isExclusive(),
                config.isAutoDelete(),
                null);
    }

    @Override
    public <T> void publishMessage(String exchange, String routingKey, T message) throws IOException {
        checkState();
        byte[] body = RabbitMqMessageMapper.mapToByteArray(message);
        Channel channel = mCommunication.getChannel();
        channel.basicPublish(exchange, routingKey, null, body);
    }

    @Override
    public <T> void registerConsumer(final RabbitMqConsumerStrategy<T> strategy,
                                     final Class<T> messageClass) throws IOException {
        checkState();
        String queue = strategy.configureQueue(mCommunication);
        Channel channel = mCommunication.getChannel();
        channel.basicConsume(queue, new DefaultConsumer(channel) {
            @Override
            public void handleDelivery(String consumerTag,
                                       Envelope envelope,
                                       AMQP.BasicProperties properties,
                                       byte[] body) throws IOException {
                T response = null;
                if (body != null && body.length > 0) {
                    response = RabbitMqMessageMapper.mapFromByteArray(body, messageClass);
                }
                strategy.handleMessage(response);
            }

            @Override
            public void handleShutdownSignal(String consumerTag, ShutdownSignalException sig) {
                if (sig != null) {
                    strategy.handleShutdown(sig);
                }
            }
        });
    }

    @Override
    public <T> int subscribeConsumer(final RabbitMqConsumerStrategy<T> strategy,
                                      final Class<T> messageClass) throws IOException {
        subscribersCounter++;
        final String queue = strategy.configureQueue(mCommunication);
        Thread subscriber = new Thread() {
            @Override
            public void run() {
                while (true) {
                    try {
                        Channel channel = mCommunication.getChannel();
                        QueueingConsumer consumer = new QueueingConsumer(channel);
                        channel.basicConsume(queue, true, consumer);
                        QueueingConsumer.Delivery delivery = consumer.nextDelivery();
                        T response = null;
                        if (delivery.getBody() != null && delivery.getBody().length > 0) {
                            response = RabbitMqMessageMapper.mapFromByteArray(delivery.getBody(), messageClass);
                        }
                        strategy.handleMessage(response);
                    } catch (InterruptedException e) {
                        break;
                    } catch (Exception e) {
                        try {
                            Thread.sleep(SUBSCRIBER_TIME);
                        } catch (InterruptedException ie) {
                            break;
                        }
                    }
                }
            }
        };
        subscriber.start();
        subscribers.put(subscribersCounter, subscriber);
        return subscribersCounter;
    }

    @Override
    public void unsubscribeConsumer(int subscriberId) throws IOException {
        if (subscribers.containsKey(subscriberId)) {
            subscribers.get(subscriberId).interrupt();
        }
    }

    @Override
    public void closeCommunication(RabbitMqCloseCommunicationStrategy strategy) throws IOException, TimeoutException {
        checkState();
        Channel channel = mCommunication.getChannel();
        if (channel != null) {
            if (strategy != null) {
                strategy.closeCommunication(mCommunication);
            }
            channel.close();
        }
        Connection connection = mCommunication.getConnection();
        if (connection != null) {
            connection.close();
        }
    }

}
