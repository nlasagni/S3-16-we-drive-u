package com.wedriveu.shared.rabbitmq.communication;

import com.rabbitmq.client.*;
import com.wedriveu.shared.rabbitmq.communication.config.RabbitMqCommunicationConfig;
import com.wedriveu.shared.rabbitmq.communication.config.RabbitMqQueueConfig;
import com.wedriveu.shared.rabbitmq.communication.strategy.RabbitMqCloseCommunicationStrategy;
import com.wedriveu.shared.rabbitmq.communication.strategy.RabbitMqConsumerStrategy;
import com.wedriveu.shared.util.Log;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.TimeoutException;

/**
 * Default implementation of a {@linkplain RabbitMqCommunicationManager}.
 *
 * @author Nicola Lasagni on 09/08/2017.
 */
public class DefaultRabbitMqCommunicationManager implements RabbitMqCommunicationManager {

    private static final String ILLEGAL_COMMUNICATION_STATE =
            "Communication has not been set up or has been closed";

    private RabbitMqCommunication mCommunication;

    private void checkState() throws IllegalStateException {
        if (mCommunication == null ||
                mCommunication.getChannel() == null ||
                !mCommunication.getConnection().isOpen()) {
            throw new IllegalStateException(ILLEGAL_COMMUNICATION_STATE);
        }
    }

    @Override
    public void setUpCommunication(RabbitMqCommunicationConfig config) throws IOException, TimeoutException {
        mCommunication = RabbitMqCommunicationFactory.getInstance().createCommunication(config);
    }

    @Override
    public String addAutoGeneratedQueue() throws IllegalStateException, IOException {
        checkState();
        return mCommunication.getChannel().queueDeclare().getQueue();
    }

    @Override
    public void addQueue(RabbitMqQueueConfig config) throws IOException {
        checkState();
        mCommunication.getChannel().queueDeclare(config.getQueueName(),
                config.isDurable(),
                config.isExclusive(),
                config.isAutoDelete(),
                null);
    }

    @Override
    public <T> void publishMessage(String exchange, String routingKey, T message) throws IOException {
        checkState();
        byte[] body = RabbitMqMessageMapper.mapToByteArray(message);
        Channel channel = mCommunication.getChannel();
        channel.basicPublish(exchange, routingKey, null, body);
    }

    @Override
    public <T> String registerConsumer(final RabbitMqConsumerStrategy<T> strategy,
                                     final Class<T> messageClass) throws IOException {
        checkState();
        final String queue = strategy.configureQueue(mCommunication);
        Channel channel = mCommunication.getChannel();
        return channel.basicConsume(queue, new DefaultConsumer(channel) {
            @Override
            public void handleDelivery(String consumerTag,
                                       Envelope envelope,
                                       AMQP.BasicProperties properties,
                                       byte[] body) throws IOException {
                T response = null;
                if (body != null && body.length > 0) {
                    response = RabbitMqMessageMapper.mapFromByteArray(body, messageClass);
                }
                strategy.handleMessage(response);
            }

            @Override
            public void handleShutdownSignal(String consumerTag, ShutdownSignalException sig) {
                if (sig != null) {
                    strategy.handleShutdown(sig);
                }
            }
        });

    }

    @Override
    public void unregisterConsumer(String consumerTag) throws IOException {
        if (mCommunication != null && mCommunication.getChannel() != null) {
            mCommunication.getChannel().basicCancel(consumerTag);
        }
    }

    @Override
    public void closeCommunication() throws IOException, TimeoutException {
        closeCommunication(null);
    }

    @Override
    public void closeCommunication(RabbitMqCloseCommunicationStrategy strategy) throws IOException, TimeoutException {
        if (mCommunication != null) {
            Channel channel = mCommunication.getChannel();
            if (channel != null) {
                if (strategy != null) {
                    strategy.closeCommunication(mCommunication);
                }
                channel.close();
            }
            Connection connection = mCommunication.getConnection();
            if (connection != null) {
                connection.close();
            }
        }
    }

}
