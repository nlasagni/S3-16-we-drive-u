package com.wedriveu.shared.rabbitmq.communication;

import com.wedriveu.shared.rabbitmq.communication.config.RabbitMqCommunicationConfig;
import com.wedriveu.shared.rabbitmq.communication.config.RabbitMqQueueConfig;
import com.wedriveu.shared.rabbitmq.communication.strategy.RabbitMqCloseCommunicationStrategy;
import com.wedriveu.shared.rabbitmq.communication.strategy.RabbitMqConsumerStrategy;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

/**
 * @author Nicola Lasagni on 09/08/2017.
 */
public class DefaultRabbitMqCommunicationManager implements RabbitMqCommunicationManager {

    private static final String ILLEGAL_COMMUNICATION_STATE =
            "Communication has not been set up or has been closed";

    private RabbitMqCommunication mCommunication;

    private void checkState() throws IllegalStateException {
        if (mCommunication == null ||
                mCommunication.getChannel() == null ||
                !mCommunication.getChannel().isOpen()) {
            throw new IllegalStateException(ILLEGAL_COMMUNICATION_STATE);
        }
    }

    @Override
    public void setUpCommunication(RabbitMqCommunicationConfig config) throws IOException, TimeoutException {
        mCommunication = RabbitMqCommunicationFactory.getInstance().createCommunication(config);
    }

    @Override
    public String addAutoGeneratedQueue() throws IllegalStateException, IOException {
        checkState();
        return mCommunication.getChannel().queueDeclare().getQueue();
    }

    @Override
    public void addQueue(RabbitMqQueueConfig config) throws IOException {
        checkState();
        mCommunication.getChannel().queueDeclare(config.getQueueName(),
                config.isDurable(),
                config.isExclusive(),
                config.isAutoDelete(),
                null);
    }

    @Override
    public <T> void publishMessage(String exchange, String routingKey, T message) throws IOException {
        checkState();
        byte[] body = RabbitMqMessageMapper.mapToByteArray(message);
        Channel channel = mCommunication.getChannel();
        channel.basicPublish(exchange, routingKey, null, body);
    }

    @Override
    public <T> void registerConsumer(final RabbitMqConsumerStrategy<T> strategy,
                                     final Class<T> messageClass) throws IOException {
        checkState();
        String queue = strategy.configureQueue(mCommunication);
        Channel channel = mCommunication.getChannel();
        channel.basicConsume(queue, new DefaultConsumer(channel) {
            @Override
            public void handleDelivery(String consumerTag,
                                       Envelope envelope,
                                       AMQP.BasicProperties properties,
                                       byte[] body) throws IOException {
                T response = null;
                if (body != null && body.length > 0) {
                    response = RabbitMqMessageMapper.mapFromByteArray(body, messageClass);
                }
                strategy.handleMessage(response);
            }

            @Override
            public void handleShutdownSignal(String consumerTag, ShutdownSignalException sig) {
                strategy.handleShutdown(sig);
            }
        });
    }

    @Override
    public void closeCommunication(RabbitMqCloseCommunicationStrategy strategy) throws IOException, TimeoutException {
        checkState();
        Channel channel = mCommunication.getChannel();
        if (channel != null) {
            if (strategy != null) {
                strategy.closeCommunication(mCommunication);
            }
            channel.close();
        }
        Connection connection = mCommunication.getConnection();
        if (connection != null) {
            connection.close();
        }
    }

}
